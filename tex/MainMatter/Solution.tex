% ------------------------------------------------------------------------ %
% !TEX encoding = UTF-8 Unicode
% !TEX TS-program = pdflatex
% !TEX root = ../Tesi.tex
% !TeX spellcheck = en_US
% ------------------------------------------------------------------------ %
%
% ------------------------------------------------------------------------ %
% 	PROPOSED SOLUTION
% ------------------------------------------------------------------------ %
%
\chapter{Proposed Solution}
%
\label{cap:proposedsolution}
%
% ------------------------------------------------------------------------ %
%
\par In this chapter I will report the development of the solution step by step, with full use cases. %The chapter starts with a list of similar solutions already developed, highlighting the differences between them and my thesis work.
 I decided to decompose the chapter with tree mains sections: the first explains the choice of the network, the architecture, the naming service, etc. It lays the foundations for the second part: the definition of the Liquid Android middleware, or better the structure of what will do the magic: intercept, encapsulate, spread, and generate distributed intents in the network so made. The two parts are closely related, therefore their relation was taken into account when I made my choice.\\
The real implementation of the valid solution is left for the next chapter.
%
\section{General Idea}
\par To better explain what I consider solution for my work it is important to
understand the playground to my work. As said in the previous Chapter, \ref{cap:probanalysis}, I
am trying to extend the Android operating system by adding some functionalities to make it similar to a distributed OS, without the need of rooting it or change its standard working mechanism and components, staying in the 7th layer of the ISO/OSI stack , the application layer. Using already developed and operating tools, and respecting all the above listed constraints I am going to make mobile devices in a LAN network communicate and cooperate like they were using a single coherent distributed operating system.
In order to understand what is needed and how it is possible to solve the problem
it is fundamental to understand the type of stack and the network structure
we have to face, and standard Android working principle, in particular the intent resolution mechanism already described in \figurename~\ref{fig:2.4}.\\
Only having clear in mind the problem and its structure it is possible to find the best possible solution. In particular it is possible to decompose the main problem in some sub-problems, which can be understood as general steps in doing similar works of extending a mobile OS to become a distributed OS:
\begin{itemize}
	\item Network architecture, that is the structure and the classification of the nodes involved in the distributed system. As previously said it has to be as reliable  as possible and allow dynamic connection due to the fact that nodes are mobile devices and can be easily moved in and out the network range.
	\item Communication model, that is the way in which involved actors perform the communication. It has to be compliant to M2M, and possibly to H2M communication, and as lightweight as possible to allow fast exchange of messages and data between the network nodes.
	\item Data model, as discussed before in the Chapter \ref{cap:statoarte}, when building distributed systems it is also important to guarantee that data are managed correctly by adopting a consistency policy.
\end{itemize}
It is also necessary to identity the main actor involved in the problem, they are mainly two:
\begin{itemize}
	\item Server application, it is the main actor of this thesis work, it must be an Android application which once installed on a compatible Android device can receive resolve and forward Android intents. It contains the logic and the controllers needed to handle the network structure, find other devices in the network, send and receive messages. It is responsible of resolving all the three sub-problems described above. The server application has also the double function of receiving a message from the network and translate it in a local intent to be resolved by the Android operating system, but also it can act as a client by forwarding a received intent from a third party client application to another server in the net, by encapsulating the intent in a network message.
	\item Clients, can be applications developed in several ways, they are those which are asking to the so called servers to complete task for them. In this case clients could be any kind of third party Android application installed in the device, also running the server component, generating implicit Android intents that need to be resolved by the OS. 
\end{itemize}
Once defined the main actors of the problem I am facing, the next step is to understand how they can interact and communicate. As previously described defining the problematic scenarios in the Chapter \ref{cap:probanalysis}, the Liquid Android middleware in the best case would be a system service which users can control to distribute intents in the local network by using the WiFi chip of the devices.
\begin{figure}[h]
	\centering
	\includegraphics[width=.9\textwidth]{esempio1}
	\caption{Liquid Android working example}
	\label{fig:4.2}
\end{figure}
The \figurename~\ref{fig:4.2} shows exactly how the middleware is supposed to work. In the figure the two devices are both supposed to be connected to the same local network \textit{(they are under the same WiFi access point)} and they are executing any standard Android OS version starting from 4.4 KitKat \textit{(API level 19)}. The so called, in the picture, \textit{Device 1} is executing a third party application activity \textit{(a client)}  which contains a valid clickable URL link. By clicking a link, typically, Android applications generate an implicit intent asking to the OS to open and show the page linked by the URL. Usually, in the absence of other applications capable of solving this kind of implicit intent, the process ends with the opening of a browser in the same device, which opens the URL in one of its activities. In this case the Liquid Android application server, installed on both devices, should to tell the OS that it can handle that implicit intent, find the other devices in the net, in this case the so called \textit{Device 2}, le the user choose with which device complete the task, convert the intent in a network message and send it to that device. Once the message arrived to the \textit{Device 2} the Liquid Android middleware server application is responsible to translate again the received message into the starting implicit intent sent by the \textit{Device 1} and to start the very same resolution mechanism for that intent by its own Android operating system, which should end by the opening of a browser activity to view the page.\\
It is clear that a solution for this scenario would be also, once implemented, a solution for the second problematic scenario proposed in Section \ref{devAPI}. In fact we can consider the development of an API to build native Android distributed systems as a sub problem of the first one, already described above and in Section \ref{middlewarescenario}. The implemented version of the general solution could be also used as a library to implement special purposes similar systems by simply extending my framework and including its implemented Java classes in other Android applications projects. For these reasons in developing the solution I will try to make it as clear as possible, and to parametrize as far as possible the settings variable of my framework to make it easily extensible and ready to use buy other Android developers.\\
I would like now to list the goals that my work has to match, in order to be a valid proposal for solving the given problem. These goals are not to be intended as set in stone, they are the general motivation that leads to construct a prototype of the proposed software architecture. According to my thoughts during the development, it is possible to identify the following goals:
\begin{itemize}
	\item The middleware must work without any proprietary application: it has to interface itself to the upper layer without installing any other application of any vendor in the owned device. It must be completely neutral to the market, it must work with any version of the Android operating system starting from the API level 19, also with Android customized versions developed by device maker like Samsung, LG, Huawei and any other brand. It is the fundamental requirement to create heterogeneous applications and to separate the various closed solutions of today and an open solution for everyone in the future.
	\item The middleware has to simplify the life of the developer, he should not have to worry too much about the substrates, he should be able to fast prototype. The developer should see my framework as help for his work. The idea is to provide a ready to use service, with which it is possible create new application by exploiting it.
	\item The middleware should offer the user the possibility to access directly to other devices in the network without the need of configure anything. Users, once installed the middleware should use its functionalities of receiving/forwarding intents in a transparent way, in the same way they use other applications and with the same mechanism they learned by using the standard Android operating system.
\end{itemize}
The next sections contain all the steps necessary to have a full working system.
Firstly I would solve the, let me call it \textit{general theoretical problem} by dividing it as discussed above and providing the solution for each of them, taking into account also the data management scenario. Then I would like to present the structure of the development API, while the actual implementation of the working Liquid Android application is left for the next chapter with some working tests and a deep component analysis.


\section{Proposed Solution}
\par In this section i will perform an in depth analysis of the possible solution to the given problem: how I can extend the Android OS providing it distributed functionalities.
\subsection{Network Architecture}
The first step while creating a distributed system is to define the networking architecture, in particular I must define the kind of nodes involved in the system and the way in which they interact, what they can do, which operation they can perform and in which way. As mentioned earlier the network architecture of the system must fulfill the following requirements:
\begin{itemize}
 \item \textit{dynamicity}, it must allow any device to perform the dynamic connection, and also disconnection, to the distributed system at any time, since the nodes of the network are mainly mobile devices and they can be moved easily. Nodes can \textit{JOIN} and \textit{LEAVE} every time, and the network must accommodate them automatically.
  \item \textit{simplicity}, the network must be as simple as possible, it should not need any particular configuration on the nodes to \textit{JOIN}. Any node should perform other nodes \textit{DISCOVERY} in the network in a easy way without the need to know them a priori.
 \item \textit{reliability and security}, are important non functional requirements in such a system. I want to make the network reliable and secure as much as possible by the adoption of standard software engineering techniques.
\end{itemize}
The network architecture that fits better all the requirements listed above is certainly a P2P network. As seen in \ref{P2P}, in peer-ro-peer networks there is not a clear distinction between clients and servers, in fact a peer-to-peer network is designed around the notion of equal peer nodes simultaneously functioning as both "clients" and "servers" to the other nodes on the network.

\begin{figure}[h]
\centering
\includegraphics[width=.9\textwidth]{P2Pnetwork}
\caption{P2P Liquid Android network example}
\label{fig:4.3}
\end{figure}
I think that an \textit{unstructured P2P architecture} is the best choice for my system due to the fact that it do not impose a particular structure on the overlay network by design and data is still exchanged directly over the underlying TCP/IP network, so at the application layer peers are able to communicate with each other directly, via the logical overlay links. In \figurename~\ref{fig:4.3} there is an example of my architecture in which different devices are in range under the same local network and they can communicate sending intents and data.\\
To obtain this kind of structure, and let it change dynamically depending on the devices in range, I need to equip the devices with a \textit{network service}. In computer networking, a network service is an application running at the network application layer and above, that provides data storage, manipulation, presentation, communication or other capability which, in this case will be used in combination with a peer-to-peer architecture based on the application layer network protocols. Different services use different packet transmission techniques. In general, packets that must get through in the correct order, without loss, use TCP, whereas real time services where later packets are more important than older packets use UDP. For example, file transfer requires complete accuracy and so is normally done using TCP, and audio conferencing is frequently done via UDP, where momentary glitches may not be noticed. In this case I will adopt the TCP transport layer because I need to transfer packets in reliable way, as much as possible, and also avoid network congestions, the UDP protocol in fact lacks built-in network congestion avoidance while TCP has it.\\
To fulfill the above listed requirements of dynamicity and simplicity the right approach should be the Zeroconf one, already discussed in \ref{zeroconf}. Using a Zeroconf implementation to register and discover the service in the LAN will let the node to connect dynamically and in a easy way to the distributed system. The three main operation a node can perform are:
\begin{itemize}
	\item \textit{JOIN}, to join the system a node must activate the network service, it must provide an internal endpoint for sending or receiving data in the computer network. The best abstraction to do that is to open a socket, as seen in \ref{socket}. In particular, a TCP socket is characterized by two main parameters: the \textit{IP} and the service \textit{PORT}. In my system the TCP socket is a great choice because, as already stated, it is a network abstraction and it can be used to let communicate heterogeneous devices and can be implemented in several different ways using basically any development language. By knowing the couple of variable of the network service another device can send message, streams and so on, to it through the TCP socket.  Since mobile devices changes frequently their connections variables, because of their nature to be easily moved from one place to another, we need a system that can identify them dynamically. The name of the service and the chosen transport layer can be established once for all and they can never change. In this environment Zeroconf provides service registration and discovery. By registering the service name, port, and transport layer the node can be found in the LAN by other nodes looking for that kind of service. In this way nodes do not need to know, a priori, the two variables, IP and PORT of any node in the network, to communicate with each other, they, indeed, need only to know the service name and the chosen transport layer to find other nodes in the network.
	\lstinputlisting[language=Java , caption=Zerconf registration example , label=code:4.1]{Codici/registerservice.java}
	The snippet of code \ref{code:4.1} is an example of how in Android it is possible to register a service using the Zeroconf approach. Once registered the service Zeroconf provides name resolution functionalities to discover other nodes and then connect to them to start the communication.
	\item \textit{LEAVE}, I want that a node can decide whether join or leave the network at any time. To leave the network a node should only unregister the service registered using Zeroconf and then close the socket to avoid accidental or malicious connections.
	\item \textit{SEARCH}, since the network is dynamic, it is necessary to determine how the nodes, once the service has registered, can search for and find other nodes. As already mentioned describing the \textit{JOIN} operation Zeroconf also provide the network service discovery and the naming resolution mechanism. In this case Zeroconf uses a \textit{Domain Name System (DNS) based Service Discovery}, the so called \textit{DNS-DS}. DNS-SD allows clients to discover a named list of service instances, given a service type, and to resolve those services to \textit{hostnames} using standard DNS queries. The specification is compatible with existing \textit{unicast DNS} server and client software, but works equally well with \textit{multicast DNS (mDNS)} in a zero-configuration environment. Each service instance is described using a \textit{DNS SRV} and \textit{DNS TXT} record. A client discovers the list of available instances for a given service type by querying the \textit{DNS PTR} record of that service type's name; the server returns zero or more names of the form "<Service>.<Domain>", each corresponding to a SRV/TXT record pair. The SRV record resolves to the domain name providing the instance, while the TXT can contain service-specific configuration parameter. Once completed the resolution process the node which started it to find other nodes in the network, knows any couple of IP/PORT of their open sockets and can connect to them to exchange messages or transfer data.
\end{itemize}
Given the network structure security is obviously a non functional requirement in building my system, but since my entire middleware, once connected, will allow to send and execute any kind of task, in the form of implicit intents, to each device involved I need to make some considerations about the security of such a system. The security of my system is highly influenced by the underlying physical network, if the LAN access is secured and protected my system will be, indeed, enough secure. The network should be protected using a firewall and the service ports used by the device involved in the system should not be accessible from the outside of the LAN. Moreover the WiFi should be protected using a strong password and a secure and updated access protocol like the\textit{WPA2}. Furthermore, I want that users of my system are aware of the fact that it is running, so once the service is activated users will be alerted by a notification in the appropriate Android notification area.
 
 \subsection{Communication Model}
 Once the network is up the second step is let the device communicate to cooperate giving, to the final users, the feeling that they are working with a single big distributed operating system. To achieve this goal, as already explained several times, my system is supposed to intercept implicit intents, let the user select a target device, or a group of them, to perform the task, send it and once arrived perform it in the selected device or group devices. With TCP sockets it very easy to exchange messages between networked devices, so it is equally easy to understand why I have chosen a message oriented structure as the communication model, briefly presented in \ref{messageo}, for my system. Furthermore, as already stated with the \tablename~\ref{tab:comp} such a model gives me more freedom of choice regarding certain characteristics that the system must have, I want the communication is:
 \begin{itemize}
	\item \textit{concurrent}, in the original Android OS when an intent resolution mechanism is started by any other component of the system, for example an application activity, the OS stops its execution to perform, in foreground, the task the intent contains. I want to leave unchanged this kind of mechanism in my system, so when a, let me call it, \textit{distributed intent} arrives from the socket, the operating system must treat it exactly as if it were a \textit{local intent} and execute it in the same way it does with other intents. The arrival of a new distributed intent from another device is the event which triggers the standard OS resolution technique by suspending any other operation. I want the network listen and accepts messages with distributed intents to solve at any moment, in a fully concurrent way, so the last intent is triggered the first it is resolved and executed in a \textit{LIFO}, last in first out, way like in a stack structure.
	\item \textit{asynchronous}, the standard intent resolution mechanism, like many other in the Android operating system, is mainly asynchronous. When an implicit intent is triggered it will be performed without knowing, a priori, what application will execute the task and how. To be more clear, for example when an application ask the OS to open a map of a place, the application which started the process do no need to know if the system completed the task and with which results. I want that my system do not need to change this behavior, if an operation need to be performed the intent is triggered and the OS reacts as usual without the need to send back acknowledgment messages \text{ACKs}. When it is necessary to synchronize the communication among the various components involved when an implicit intent is triggered Android provides a mechanism, using the system function \textit{startActivityForResult(intent)}, to send the result back to the caller. I intend to keep the same mechanism also when dealing with distributed intents, but I want to maintain an asynchronous approach also in this case, the caller could continue its execution without waiting for the results and then, once done, receive back the response, in the form of another distributed intent, from the called. I will give further details of this case when presenting the kind of messages can be sent using my system and the data model solution part.
 \end{itemize}

Now the difficult part is establish how intents can be sent through the sockets and which kind of messages my system can send and then handle to perform various kind of tasks.\\
The next step, hence, is to find a way to send the intents from a device to another without loosing information and once they are arrived to be executed like they were local intents. To do this job it is necessary to analyze in dept what an intent is in Android and what it can contain.\\
As showed in the chapter \ref{cap:statoarte} in \ref{intents} intents are the way in which standard Android framework's components communicate among each other, and they also represent the abstraction of actions to be performed by Android applications. In the Android developer framework an intent is implemented as a Java Class containing the information and data to perform the task. An intent is an abstract description of an operation to be performed. It can be used in various ways: with \textit{startActivity} to launch an Activity, with \textit{broadcastIntent} to send it to any interested \textit{BroadcastReceiver} components, and  with \textit{startService(Intent)} or \textit{bindService(Intent, ServiceConnection, int)} to communicate with a background Service. However its most significant use is in the launching of activities, where it can be thought of as the glue between activities. It is basically a passive data structure holding an abstract description of an action to be performed \cite{android2017intent}.\\
Every implicit intent is characterized, mainly, by an \textit{ACTION}, \textit{DATA} and a bundle of \textit{EXTRAS}.
\begin{table}[h]
	%
	\caption{Intent Structure}
	%
	\label{tab:intent}
	%
	\centering
	\begin{center}
	
	%
	\begin{tabular}{>{\centering\arraybackslash} m{0.15\textwidth}p{0.4\textwidth}p{0.4\textwidth}}
		%
		
		\toprule
		%
		\centering\textbf{Attribute} & \centering\textbf{Description}  &\begin{minipage}[t]{0.4\textwidth}
			\centering
		\textbf{Examples}
		\end{minipage} \\
		%
		\midrule
		%
		\centering\textit{ACTION} & \begin{minipage}[t]{0.4\textwidth}
			\centering
		The general action to be\\ performed.
		\end{minipage} & \begin{minipage}[t]{0.4\textwidth}
		\centering
		ACTION\_VIEW\\ACTION\_EDIT
		\end{minipage}\\ %fine riga tabella
		&&\\
		\centering\textit{DATA} & \begin{minipage}[t]{0.4\textwidth}
			\centering
		The data to operate on,\\expressed as a Uri.
		\end{minipage} &
		\begin{minipage}[t]{0.4\textwidth}
			\centering
		content://contacts/people/1 \\ tel:123
		\end{minipage}\\  %fine riga tabella
		&&\\
		\centering\textit{CATEGORY} & \begin{minipage}[t]{0.4\textwidth}
			\centering
			Gives additional information\\about the action to execute.
		\end{minipage} &
		\begin{minipage}[t]{0.4\textwidth}
			\centering
			 CATEGORY\_LAUNCHER \\  CATEGORY\_ALTERNATIVE
		\end{minipage}\\  %fine riga tabella
		&&\\
		\centering\textit{TYPE} & \begin{minipage}[t]{0.4\textwidth}
			\centering
			Specifies an explicit type \\(a MIME type) of the intent data. Normally the type is inferred\\ from the data itself. 
		\end{minipage} &
		\begin{minipage}[t]{0.4\textwidth}
			\centering
			type */*
		\end{minipage}\\  %fine riga tabella
		&&\\
		\centering\textit{EXTRAS} & \begin{minipage}[t]{0.4\textwidth}
			\centering
		This is a Bundle of any additional information. This can be used to provide extended information to the component.
		\end{minipage} &
		\begin{minipage}[t]{0.4\textwidth}
			\centering
			EXTRA\_TEXT\\
			EXTRA\_TITLE
		\end{minipage}\\  %fine riga tabella
	
		\bottomrule
		%
	\end{tabular}
\end{center}
	%
\end{table}
The \tablename~\ref{tab:intent} explains in depth what an intent could contain, of course there are many types of action, data, categories and extra that are not reported here for reasons of brevity but that can be found in \cite{android2017intent}. The real problem, for the purposes of my system, is that the Android intent Java Class can no be serialized,automatically and send through the socket as it is. In computer science serialization is the process of translating data structures or object state into a format that can be stored, or transmitted across a network connection link, and reconstructed later in the same or another computer environment.\\ When the resulting series of bits is reread according to the serialization format, it can be used to create a semantically identical clone of the original object \cite{marshall2015c++}. In a Java environment, like the Android one, Java Classes that implements the \textit{Serializable interface} can be automatically serialized, by the environment itself, and sent through a socket  and then automatically deserialized to reconstruct the original sent object by the receiver, but as already told the intent Class does not implement this functionality. I need therefore to find a way to do this process in a fully functional and also efficient way. There are, actually, many alternatives to accomplish this objective. For example I could generate a new Java Object, containing all the intent attributes, that implements the Java Serializable interface, convert intents to this new Object and then let Java perform its automatic serialization/serialization. As an alternative I could generate some kind of semi-structured data, using a well know, let me call it \textit{container language}, such as JSON or XML, which can be easily sent, as a string, over the socket and then parsed to rebuild the original Java Object.\\
Since the effort required to develop one of the two solution, presented above as examples, is practically the same, I decided to opt for the second alternative, using a JSON structure, because it has substantial advantages.\\
JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language, it is completely language independent. These properties make JSON an ideal data-interchange
language \cite{w3c2007introducing}.\\
It is based mainly on two types of structures:
\begin{itemize}
	\item Key/Value pair set: it can be considered an object of an Object Oriented programming language,
	\item Collection of elements: it can be considered an array of Objects.
\end{itemize}
By converting any possible implicit intent in a \textit{JSON-intent} the system complies with the following properties:
\begin{itemize}
	\item \textit{M2M communication}, and also \textit{M2H communication}, as already stated JSON are really easy to read and understand by human and also by machines,
	\item \textit{lightweight messages} and also \textit{small overhead}, it is well known that Serialization in Java produce a big overhead and serialization/deserialization to be more general lacks efficiency. JSON are merely \textit{well formatted Strings} which can be sent unaltered on the socket without the need be further converted. The sender send the JSON as a string and the receiver gets exactly that string.
	\item \textit{freedom}, JSON is optimized to be used with a great variety of programming languages, the creation of a \textit{JSON-intent} opens up various possibilities for further development: using the correct syntax, any device, even non-Android, could be a client of my system. In this way it would be possible to send original Android intents to any Android device, with my service installed and active, from a Client running in different OS and using different programming languages. It is possible, in fact, to use Zeroconf to find the service in many other environment and to connect to the socket to send JSON-intents to the connected Android devices.
\end{itemize}
To obtain a general solution to convert any possible Android intent in to a JSON-intent, and viceversa, i need to define the syntax of new object which must fit as much as possible to the structure of the Android intent Class. In fact it would be very easy to convert the major fields that characterize a given intent that are mostly correctly formatted strings, if it were not for the fact that the bundle of extras can contain different types of structured data.
\subsubsection{JSON-Intent sintax}\label{syntax}
In this subsection I am going to define step by step the syntax of my solution, explaining with listings and images all the elements.
An important and remarkable reflection is needed here: unfortunately it is not possible for me alone to consider every kind of intents and to convert properly any kind of data, but my system will work with great majority of them. It is in fact unlikely that implicit intents will contain strange structured data types or \textit{Parcelables and Serializable} data which are usually used with implicit intents, which, for construction of the operating system, my system can not handle. For these reason I am not going to support, with this solution, that kind of data, since it would be very difficult, and highly inefficient, send and reconstruct Parcelables and Serializable data types over my system. That said, I want to proceed with the definition of the syntax of the JSON-Intents.\\
\begin{figure}[h]
	\centering
	\includegraphics[width=.9\textwidth]{intentUML}
	\caption{UML  structure for an Intent}
	\label{fig:4.4}
\end{figure}
In \figurename~\ref{fig:4.4} it is shown the complete structure of an intent including the detailed description, using an UML model, of the bundle that is responsible of holding the Extras. The bundle is a sort of container of a non predetermined number of couples \textit{<Key,Value>} in which the Key is always an arbitrary String, while the Value can be any of the structured data types listed in the schema.
The \textit{"*"} notation at the end of any attribute in the bundle, means precisely that the number of \textit{<Key,Value>} is variable, and optional, for any kind of structured Value data type.\\
I have already analyzed the structure of an Android intent object in the \tablename~\ref{tab:intent}, now I am reproducing the same structure to convert it in a JSON-intent. Using some tables i would explain all the syntax i have created. In the \tablename~\ref{tab:JSON-Intent} it is shown the general structure for the JSON-Intent, precisely in the first column, \textit{Name}, there is in bold the String keyword used in JSON to identify the field. In the second column, \textit{Type}, it is explained which kind of data type the field, identified by the keyword in the first column, contains. Since JSON allows to store only \textit{String},	\textit{Boolean}, \textit{JSON Array}, \textit{Number} and \textit{JSON Object} data types in the third column, \textit{description}, there is a short explanation of how the conversion is performed.
\bigskip
\bigskip
\bigskip
\bigskip
\begin{table}[h]
	%
	\caption{JSON-Intent fields}
	%
	\label{tab:JSON-Intent}
	%
	\centering
	\begin{center}
		
		%
		\begin{tabular}{>{\centering\arraybackslash} m{0.15\textwidth}p{0.25\textwidth}p{0.55\textwidth}}
			%
			
			\toprule
			%
			\centering\textbf{Name} & \centering\textbf{Type}  &	\textbf{Description} \\
			%
			\midrule
			%
			\centering\textbf{action} & \begin{minipage}[t]{0.25\textwidth}
				\centering
				String
			\end{minipage} & \begin{minipage}[t]{0.55\textwidth}
				It was a String also in the original Intent Object and do not need to be further converted. It is used also to identify, by using intent filters, which applications can execute the intent once arrived to the receiver.
			\end{minipage}\\%fine riga tabella
		&&\\
			\centering\textbf{[data]}\footnotemark[1] & \begin{minipage}[t]{0.25\textwidth}
				\centering
				String
			\end{minipage} & \begin{minipage}[t]{0.55\textwidth}
				It was a URI type in the Intent Object which can be easily stored as a string by using the URI.toString() method in Java.
			\end{minipage}\\%fine riga tabella
		&&\\
			\centering\textbf{[categories]} & \begin{minipage}[t]{0.25\textwidth}
			\centering
			Array\\<Category> \footnotemark[2]
		\end{minipage} & \begin{minipage}[t]{0.55\textwidth}
			It was a Set of Strings in the Intent Object so it can be converted in an array of Category JSON Objects \textit{(JSON Array)} containing all the category of the intent.
		\end{minipage}\\%fine riga tabella
		&&\\
			\centering\textbf{[type]}\footnotemark[1] & \begin{minipage}[t]{0.25\textwidth}
			\centering
			String
		\end{minipage} & \begin{minipage}[t]{0.55\textwidth}
			It was a String also in the original Intent Object and do not need to be further converted.
		\end{minipage}\\%fine riga tabella
		&&\\
			\centering\textbf{[extras]}\footnotemark[1] & \begin{minipage}[t]{0.25\textwidth}
			\centering
			Array\\<Bundle Object>\footnotemark[2]
		\end{minipage} & \begin{minipage}[t]{0.55\textwidth}
			It is a collection of all possible extras, it has to be converted in complex JSON Object which I will describe in the next tables.
		\end{minipage}\\%fine riga tabella	
			\bottomrule
			%
		\end{tabular}
	\end{center}
	%
\end{table}
\footnotetext[1]{The notation [Field] means that the field is optional}
\footnotetext[2]{The notation Array<Type> means that the Array contains Objects of that type}

Since \textit{categories} and, as anticipated, \textit{extras} are complex fields, containing array data types, introduced by me, I need to give further explanations of my choices in translating this objects form Java to JSON.

\begin{table}[h]
	%
	\caption{Category fields}
	%
	\label{tab:category}
	%
	\centering
	\begin{center}
		
		%
		\begin{tabular}{>{\centering\arraybackslash} m{0.15\textwidth}p{0.25\textwidth}p{0.55\textwidth}}
			%
			
			\toprule
			%
			\centering\textbf{Name} & \centering\textbf{Type}  &	\textbf{Description} \\
			%
			\midrule
			%
			\centering\textbf{category} & \begin{minipage}[t]{0.25\textwidth}
				\centering
				String
			\end{minipage} & \begin{minipage}[t]{0.55\textwidth}
				It was a String also in the original Intent Object and do not need to be further converted.
			\end{minipage}\\%fine riga tabella		
			\bottomrule
			%
		\end{tabular}
	\end{center}
	%
\end{table}

In the \tablename~\ref{tab:category}, using the same notation of the previous table, it is shown how the \textit{Category JSON object} is structured. It is, merely, a simple object containing a single field using the keyword \textit{category} with a String value which is any possible Android intent's category.
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip

\begin{table}[h]
	%
	\caption{JSON-Bundle Object fields}
	%
	\label{tab:Bundle}
	%
	\centering
	\begin{center}
		
		%
		\begin{tabular}{>{\centering\arraybackslash} m{0.15\textwidth}p{0.25\textwidth}p{0.55\textwidth}}
			%
			
			\toprule
			%
			\centering\textbf{Name} & \centering\textbf{Type}  &	\textbf{Description} \\
			%
			\midrule
				%
			\centering\textbf{[key]\footnotemark[1]} & \begin{minipage}[t]{0.25\textwidth}
				\centering
				String
			\end{minipage} & \begin{minipage}[t]{0.55\textwidth}
				It contains the keyword, an arbitrary string, used to store the specific extra in the original Java intent object.
			\end{minipage}\\%fine riga tabella		
			&&\\
			%
			\centering\textbf{type} & \begin{minipage}[t]{0.25\textwidth}
				\centering
				String
			\end{minipage} & \begin{minipage}[t]{0.55\textwidth}
				It is a string which describes the type of structured Java data type, it is used to correctly reconstruct the original Intent Object.
			\end{minipage}\\%fine riga tabella		
			&&\\
			\centering\textbf{data} & \begin{minipage}[t]{0.25\textwidth}
				\centering
				Variable
			\end{minipage} & \begin{minipage}[t]{0.55\textwidth}
				This filed is the one which contains the actual data, it can be a primitive data type such as a boolean a double and so and, or a supported array. The full description of this field is given in \tablename~\ref{tab:data}.
			\end{minipage}\\%fine riga tabella		
			\bottomrule
			
			%
		\end{tabular}
	\end{center}
	%
\end{table}
In the same way the \tablename~\ref{tab:Bundle} shows the structure of the JSON-Bundle object. Every single JSON-Bundle object represent a possible \textit{extra} of the original Java intent. The field \textit{key} contains the string keyword used to identify the extra. The \textit{type} field contains one of the keywords, in bold, defined in the next table, which is a String used to identify the structured Java data type, used to perform the so called \textit{deserialization}, by reconverting the JSON-Intent in a Android Java intent object. Depending on the type of data that it is necessary to store the \textit{data} field can contain the actual data, if the original Java type was a primitive data type, or an array of JSON-Bundle objects without the field \textit{key}, if the original data type was an Array or an ArrayList.\\

	%
	

		%
		\begin{longtable}{|p{0.19\textwidth}|p{0.17\textwidth}p{0.17\textwidth}p{0.37\textwidth}|}
			%
			
			\toprule
			%
			\centering\textbf{Java Object} & \multicolumn{3}{ |c| }{\textbf{JSON Object}}\\
		
			%
			\midrule
			\centering\textbf{name}	& \centering\textbf{type content}  &	\centering\textbf{data type} &	\textbf{description} \\ \hline
			\multicolumn{4}{ |c| }{ }\\
			\multicolumn{4}{ |c| }{\textbf{Primitive Data Types}}\\ \hline
			&&&\\
			%
			\centering boolean & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{boolean}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
			\centering
				Boolean
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
			The data filed contains the actual boolean value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			%
			\centering byte & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{byte}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Number
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains the actual byte value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			%
			\centering CharSequence & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{charsequence}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				String
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains the actual CharSequence value converted in String.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			%
			\centering double & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{double}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Number
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains the actual double value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			%
			\centering float & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{float}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Number
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains the actual float value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			%
			\centering int & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{integer}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Number
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains the actual int value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			%
			\centering long & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{long}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Number
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains the actual long value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			\centering short & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{short}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Number
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains the actual short value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			\centering String & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{string}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				String
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains the actual String value.
			\end{minipage}\\%fine riga tabella		
			 \hline
			\multicolumn{4}{ |c| }{ }\\
			\multicolumn{4}{ |c| }{\textbf{Array Data Types}}\\ \hline
			% inizio array
			&&&\\
			\centering boolean[] & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{aboolean}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Array\\<Bundle Object>\footnotemark[2]
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains an JSON Array of Bundle Objects having in the type field \textit{"boolean"} and in the data filed the actual boolean value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			%
			\centering byte[] & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{abyte}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Array\\<Bundle Object>\footnotemark[2]
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains an JSON Array of Bundle Objects having in the type field \textit{"byte"} and in the data filed the actual byte value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			%
			\centering CharSequence[] & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{acharsequence}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Array\\<Bundle Object>\footnotemark[2]
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains an JSON Array of Bundle Objects having in the type field \textit{"charsequence"} and in the data filed the actual charsequence value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			%
			\centering double[] & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{adouble}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Array\\<Bundle Object>\footnotemark[2]
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains an JSON Array of Bundle Objects having in the type field \textit{"double"} and in the data filed the actual double value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			%
			\centering float[] & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{afloat}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Array\\<Bundle Object>\footnotemark[2]
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains an JSON Array of Bundle Objects having in the type field \textit{"float"} and in the data filed the actual float value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			%
			\centering int[] & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{ainteger}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Array\\<Bundle Object>\footnotemark[2]
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains an JSON Array of Bundle Objects having in the type field \textit{"integer"} and in the data filed the actual int value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			%
			\centering long[] & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{along}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Array\\<Bundle Object>\footnotemark[2]
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains an JSON Array of Bundle Objects having in the type field \textit{"long"} and in the data filed the actual long value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			\centering short[] & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{ashort}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Array\\<Bundle Object>\footnotemark[2]
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains an JSON Array of Bundle Objects having in the type field \textit{"short"} and in the data filed the actual short value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			\centering String[] & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{astring}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Array\\<Bundle Object>\footnotemark[2]
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains an JSON Array of Bundle Objects having in the type field \textit{"string"} and in the data filed the actual string value.
			\end{minipage}\\%fine riga tabella
			 \hline
			\multicolumn{4}{ |c| }{ }\\
			\multicolumn{4}{ |c| }{\textbf{ArrayList Data Types}}\\ \hline
			% inizio arraylist
			&&&\\
			%
			\begin{minipage}[t]{0.19\textwidth}
				\centering
				 ArrayList\\<CharSequence>
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{alcharsequence}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Array\\<Bundle Object>\footnotemark[2]
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains an JSON Array of Bundle Objects having in the type field \textit{"charsequence"} and in the data filed the actual charsequence value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			\begin{minipage}[t]{0.19\textwidth}
				\centering
				ArrayList\\<Integer>
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{alinteger}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Array\\<Bundle Object>\footnotemark[2]
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains an JSON Array of Bundle Objects having in the type field \textit{"integer"} and in the data filed the actual integer value.
			\end{minipage}\\%fine riga tabella		
			&&&\\
			\begin{minipage}[t]{0.19\textwidth}
				\centering
				ArrayList\\<String>
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				\textbf{alstring}
			\end{minipage} & \begin{minipage}[t]{0.17\textwidth}
				\centering
				Array\\<Bundle Object>\footnotemark[2]
			\end{minipage} & \begin{minipage}[t]{0.37\textwidth}
				The data filed contains an JSON Array of Bundle Objects having in the type field \textit{"string"} and in the data filed the actual string value.
			\end{minipage}\\%fine riga tabella
			
			\bottomrule
			%
			
			\caption{Possible data types}
			%
			\label{tab:data}
			%
			\centering
		\end{longtable}

In the \tablename~\ref{tab:data} there is the definition for any Java types of data my translation supports: for every Java type, listed in the first column of the table, is provided the corresponding translation, using the last three columns.\\
In this way I completed the translation of any generic Android implicit intent, which can, easily, be converted in a JSON-Intent by generating a JSON complying with the syntax defined above. The conversion process can be automatized developing an \textit{Intent Converter}, which I will include in the \textit{Liquid Android API}, which i will describe in the following sections.

\subsubsection{JSON-Intent example}
In this small subsection I would like to provide a full example of a JSON-Intent document which represents a theoretical proof of concept. Notice that I did not use all the fields, and obviously all the data types, I have defined in the previous pages: not all of them are
mandatory to have a working system and maybe they can result redundant, and and make the example more difficult to understand.\\
The use case describes a working implicit intent used to ask the Android OS to send an email.\\
In the \lstlistingname~\ref{code:4.2} there is. in Java code, an example of a method which creates an Android implicit Intent to send an email and then asks the OS to resolve that Intent by using an Activity. In the \lstlistingname~\ref{code:4.3} there is exactly the same Intent converted using the syntax proposed above by me. The JSON-Intent thus created can be easily sent through the socket and then reconverted back to the original Java Intent object.
\lstinputlisting[language=Java , caption=Implicit Intent example , label=code:4.2]{Codici/mailintent.java}
\begin{lstinputlisting}[
%	morekeywords={action, itype, category, categories, extras, type, data, key},
	language=JSON,
	caption={Conversion of the Intent in Listing \ref{code:4.2} to JSON-Intent},
	label=code:4.3]
	{Codici/mailintent.json}
\end{lstinputlisting}
\subsubsection{Possible Messages} \label{pm}
Having thus defined the communication model and language, i need now to define the possible kind of messages the system can handle: as mentioned earlier Android intents can be used with different methods to start different kinds of Android components, the are mainly 4 : 
\begin{itemize}
	\item \textit{startActivity(Intent intent)}, ask the system to start an Activity to perform the operation contained in the intent passed as parameter.
	\item \textit{startActivityForResult(Intent intent)}, it performs exactly the same operations of the previous method, farther, it is used to receive a result from the activity when it finishes. The caller activity receives the result as a separate Intent object in the activity's onActivityResult() callback.
	\item \textit{startService(Intent intent)} ask the system to start a Service to perform the operation contained in the intent passed as parameter.
	\item \textit{sendBroadcast(Intent intent)} ask the system to send a broadcast message that any app can receive.
\end{itemize}
Since my system is supposed to work, mainly, by using implicit intents, the most common method it will use will be the first. I want, also, to support the use of the other three methods, so since it is impossible to understand what kind of method it is needed only by analyzing any intent filed, i need to define standard attributes to let my system choose the right Android method to start the received intent. For these reasons my system will threat received intents with the first method unless unless otherwise specified. By including in the JSON-intent a standard extra field it is possible to support any method described above. Including in the extras array the extra with \textbf{key}:\textit{"andorid.intent.extra.LIQUIDMETHOD"}, \textbf{type}:\textit{"string"}, \textbf{data}:\textit{"RESULT" or "SERVICE" or "BROADCAST"} my system will start the received intent with the appropriate method. Furthermore during the development of my system I will analyze special cases of well known intents which need a result back, for example intents asking the OS to take a photo are supposed to receive back the taken picture.
 \subsection{Data management Model}
 The last step is to establish how the system has to manage data created, or manipulated, by sending/resolving distributed intents. I found, basically, two solutions, with both different advantages and disadvantages.
 \subsubsection{Files over socket}\label{fos}
 \begin{figure}[ht]
 	\centering
 	\includegraphics[width=.9\textwidth]{datamodel1}
 	\caption{Files Over the Socket example}
 	\label{fig:4.5}
 \end{figure}
 Since the system exploits the LAN and creates a working P2P network, it is possible to send the generated data directly using it by sending result intent or files over the socket. To continue with the previous example, in which one device of the network ask another one to take a photo, the device which perform the operation and holds the original picture can put it on the socket and send its file or the result intent,properly converted in a JSON-Intent, to the device that sent the request. In this way basically it is possible to realize any type of data management operation only by exploiting the underlying network. This first solution has the advantage of not having to use external services to the local network, indeed it do not need to use the Internet connection. There is however the drawback of having to serialize/deserialize any data to be sent over the socket.
 \subsubsection{Cloud Group}
 \begin{figure}[h]
 	\centering
 	\includegraphics[width=.9\textwidth]{datamodel2}
 	\caption{Cloud Group example}
 	\label{fig:4.6}
 \end{figure}
 It would be possible to easily implement a cloud group, with one of the well known cloud services supported by Android, such as \textit{Google drive}, where devices, while my system is running, can store and download data needed by the distributed intent and generated by executing them. In this way, the system should force to update in a cloud storage any data, such as files, text, numbers, results and so on. The cloud storage, indeed, must guarantee the devices involved to easily access right data. This means that before a user can run the system it is necessary to set up the cloud group, in order to grant access to data only to authorized users. Once the group is up, and permissions are correctly managed, every time a data is produced and stored in the cloud, it would be possible to notify devices in the group, interested in the data generated, and let them download, only by querying the cloud system.
  This second solution has the advantage that can be easily implement using existing cloud systems, but has as drawback the fact of it needs an Internet connection and some security issues because data in that way can be accessed also outside my system.
 
\section{Liquid Android API Library}\label{API}
Once found, and described the so called theoretical solution, which mainly solves the \ref{middlewarescenario} scenario, I started the concrete development of the system, trying to solve the problem and also, to create a system which can be easily extended and used to build other purposes systems.\\
In this section I will describe the \textit{Liquid Android Framework} as a development API, solving the second scenario, \ref{devAPI}, pointing out the main components, methods and configuration variables.
\subsection{General Structure}
\begin{figure}[h!]
	\centering
	\includegraphics[width=1\textwidth]{generaluml}
	\caption{Liquid Android General UML}
	\label{fig:4.7}
	\begin{tabular}{ccc}
		\textcolor{OliveGreen}{$\blacksquare$} Android Service & \textcolor{RoyalBlue}{$\blacksquare$} Android Activity & \textcolor{RoyalPurple}{$\blacksquare$} Standard Java Class\\
	\end{tabular}
\end{figure}
I want to start giving an overview of the general structure of my system. I want to have few, but fully functional, components, and to accomplish the standard design pattern \textit{Model View Controller (MVC)}.\\
In my API the model is represented by the JSON-Intent structure described in the previous sections: intents are the way in which my system communicates, so they are the main kind of data to deal with. Then there are the controller components, which are responsible to manage the data, and to build and maintain the network. Finally there are, also, \textit{User Interface (UI)} components, which are responsible for the interaction with the final user of the system.\\
In \figurename~\ref{fig:4.7} there is the complete structure, by using an \textit{UML Class Diagram} of the framework, in which it is possible to identify the various components by looking at the legend under the picture: components in light-blue are Android activity used to interact with the user, so the are, indeed UI components, while all the other classes are identifiable as controller components. The arrows in figure explain the existing relations among the class components, pointing out the way in which they interact in the system.
\subsection{Controller Components}
First of all, I want to analyze the way in which the controller components build and maintain the network and then how they send/receive JSON-Intent objects and execute them.\\
\subsubsection{NsdHelper}
It is a standard Java Class component, which we can see as a \textit{Helper Class}. It contains all the methods used to register the network service and to search and resolve other devices which are using the system, by finding other services in the LAN which are using the same name and the same transport layer. This class is an implementation of the \textit{NSD Android API} already described in \ref{androidNSD}.
Its main configuration parameters are:
\begin{itemize}
	\item \textit{SERVICE\_TYPE}, it is the string used to identify the network services in the LAN when the NsdHelper perform the register and discover operations. It uses the syntax: \textit{"\_<protocol>.\_<transportlayer>"}. 
	\item \textit{SERVICE\_NAME}, it is the instance name: it is the visible name to other devices on the network. The name is visible to any device on the network that is using NSD to look for local services. The name, also, must be unique for any service on the network, and the NSD library automatically handles conflict resolution.
\end{itemize}
 Since i want to give a flexible development API library it is possible to change this parameter by using the proper setter method or by passing two strings to the NsdHelper constructor. For example is possible to use:
 \begin{itemize}
 	\item \textit{setServiceType("\_<protocol>.\_<transportlayer>")}
 	\item \textit{setServiceName("name")}
 	\item \textit{new NsdHelper("\_<protocol>.\_<transportlayer>","name")} 
 \end{itemize} to change the configuration parameters when initializing the NsdHelper Class component.\\
Its main (public) methods are:
\begin{itemize}
	\item \textit{registerService(int port)}, this method performs the local network service registration, by using the variables described above and the service port passed as a parameter to this method.
	\item \textit{discoverServices()}, this method performs the service discovery and resolution, by scanning the local network and saving found services in a list of resolved devices, containing the connection variables of the other compatible service in the network \textit{IP} and \textit{SERVICE\_PORT}.
	\item \textit{stopDiscovery()}, this is the method used to stop the service discovery mechanism.
\end{itemize}

\subsubsection{Server}
It is a standard Java Class component holding the server functionalities of the system. It is the components which opens the sockets and then waits and listens for invocations by other devices clients. It is responsible for the reconstruction of the intent object by using the received JSON-Intent from client, and also it has to allow the concurrency and let clients connect any time.
To perform this duty my server component uses a multi-thread architecture: every time a client connects it starts a separated \textit{server-thread} to communicate with it. Once received the message the server translates it in a executable Android intent and then execute it by using one of the standard Android methods seen in the previous section when explaining the possible kind of messages.\\
Its main (public) methods are:
\begin{itemize}
	\item \textit{initializeServerSocket()}, this method initialize the \textit{ServerSocket} Java component, by automatically selecting a free port in the LAN, which waits and listens for client connections.
	\item \textit{startServer()}, this method is used to start the server-thread when a client performs an invocation, the started server-thread performs the operations contained in the received JSON-Intent message by reconstructing and passing it to the Android OS to be resolved.
	\item \textit{stopServer()}, this method closes, and destroys, the server-thread when the client invocation is finished to avoid memory leaks when using the system. 
\end{itemize}

\subsubsection{Client}
It is a standard Java Class component holding the client functionalities of the system. It is the components which connects to the  server sockets of the other devices in the network and then sends the message containing the intent to be executed. It is responsible for the conversion of the intent object in a JSON-Intent to be sent on the socket. Once created the message the client send it to the selected server and then closes itself in an asynchronous way, without waiting any ACK message or the result of the invocation.\\
Its main (public) methods is:
\begin{itemize}
	\item \textit{startClient(Intent intent)}, this method send the intent, by translating it in a JSON-Intent, to the selected server. Then the client is automatically closed to avoid possible memory leaks when using the system. 
\end{itemize}
\subsubsection{IntentConverter}
It is another \textit{Helper Class}. It contains all the logic and methods used to perform the conversion of any Android Java Intent object in JSON-Intent objects, and viceversa, using the syntax proposed in the previous chapter. This standard Java Class does not have any variable or parameter, and does not need, also a special constructor. It has only two main Static public methods that can be invoked by using the Class name. \\They are:
\begin{itemize}
	\item \textit{intentToJSON(Intent i)}, this is a Static method which performs the conversion from any Intent object, passed as parameter, to a JSON-Intent, returned by the method as a JSONObject, using the syntax created by me and explained in the previous chapter.
	\item \textit{JSONToIntent(JSONObject j)}, this is a Static method which performs the reconstruction of the Java Intent object, by parsing a well formed JSONObject. It returns a fully working original Android Intent object.
\end{itemize}
\subsubsection{LiquidAndroidService}
This is the Android background working service which really performs the extension of the Android OS giving to it distributed functionalities. When this component is started it is responsible of the initialization of the server, and the registration of the network service in the LAN, by calling the methods of the classes explained above, respectively the Server and the NsdHelper. This is a sort of container for the server side components of the middleware. It is implemented as a foreground working Android service, thus when it is in execution the user is alerted by a notification. A foreground service is a service that the user is actively aware of and is not a candidate for the system to kill when low on memory. A foreground service must provide a notification for the status bar, which is placed under the Ongoing heading. This means that the notification cannot be dismissed unless the service is either stopped or removed from the foreground \cite{devandroidrunning}.
\subsection{UI Components}
I want now to explain how the users can control the distributed intent flow, by using standard Android UI components. Even if my system is supposed to run in background it is also necessary to have few UI components to control the background working mechanisms. In this section I will not provide any screenshot of a real Android application, because in this part I want only to analyze the functionalities included in these components. I will include many real UI screenshots while presenting the Liquid Android application I have developed, using this API, in the next Chapter, \ref{cap:proofofconcept}.
\subsubsection{MainActivity}
This is the UI component responsible for control the entire system. It has four important functionalities:
\begin{itemize}
	\item \textit{Listen to implicit intents}, when an implicit intent needs to be resolved, the Android OS starts the resolution mechanism already described in \figurename~\ref{fig:2.4}.
	\lstinputlisting[language=XML , caption=Intent filter example, label=code:4.4]{Codici/intentfilter.xml}
	It searches for the best activity for the intent by comparing it to intent filters based on three aspects: \textit{Action}, \textit{Data (both URI and data type)} and \textit{Category}. A match is only successful if the actions and categories in the Intent match against the filter. So, to let the Liquid Android API listen for any kind of implicit intent, it must include an activity declared with any possible intent filter to be called when an intent need to be executed.\\
	In \lstlistingname~\ref{code:4.4} there is and example of how an Activity needs to be declared in the manifest to be called by the OS when an implicit intent like the one in the JSON-Intent in the translation example, \ref{code:4.2} is triggered.
	By extending the MainActivity component and adding any kind of intent filter to its declaration in the manifest, it is possible to listen practically to any type of existing implicit intents in the Android framework.
	\item \textit{Find other devices in the network}, the MainActivity provides also this functionality by calling the methods of the NsdHelper class, and then it shows the resolved devices in the network in a ordered list.
	\item \textit{Forward intents to selected devices}, once found the other devices in the network, the MainActivity let the user select on which device, or devices, forward the implicit intent it is managing at the moment. To perform this task the MainActivity starts the Client component and exploits its methods.
	\item \textit{Start/stop the background service}, since when the background service is working the device is exposed to many threat, the user can control it by starting and stopping it every time it is needed by clicking on some special buttons in the MainActivity. 
	
\end{itemize}

\subsubsection{ResultActivity}
This is the UI component which can be used when a received intent needs to send data or results back to the caller. This Activity implements the \textit{onActivityResult()} callback method to manage the result or data produced by the received intent. In my framework API this problem is solved by using the files over the socket approach, described in \ref{fos}, so when the callback is triggered results are sent to the caller through the socket as JSON-Intent messages or serialized files, by using the Client class to send a message to the Server component of the caller. It is necessary to have this activity since it is impossible to call the \textit{startActivityForResult(intent)} method from a background service in Android.

\subsection{Use Cases}
The full API code is available at \href{https://github.com/mola15/LiquidAndroid}{github.com/mola15/LiquidAndroid}, which is a public GitHub repository, so anyone can read, clone use and modify my code for different purposes.\\
As already said several times I will use this API to fully develop the Liquid Android APK which will be a working solution for the first and third problematic scenario, but the Liquid Android API can be used as an Android library in the development of native Android distributed applications. By including my API in any development project it is possible to speed up the process by exploiting my working mechanisms and my methods already developed. Since the API is in Java is just as easy to extend the classes and override some of my methods to accomplish special purposes distributed systems.\\
Exploiting my system would be easy to develop for example:
\begin{itemize}
	\item Distributed Android Computing systems, in which Android devices can share hardware resources to reach a common goal.
	\item Android Computer Cluster, in which Android devices can be seen as node of clusters to perform the same task, controlled and scheduled by software.
	\item Distributed Android File system, by refining the data management model.
\end{itemize}
Furthermore it is possible to adapt my work to accomplish many other purposes, at the end of the next chapter I will present a real, concrete small application, which exploits my system and represent a real use case for my framework.

%
% -----------------------------END--------------------------------- %